(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{"5FlP":function(e,t,n){"use strict";n.r(t);var a=n("q1tI"),l=n.n(a),i=n("Bl7J"),r=n("vrFN"),o=(n("rGqo"),n("yt8O"),n("Btvt"),n("RW0V"),n("91GP"),n("7ljp")),s={h1:function(e){return l.a.createElement("h1",Object.assign({className:"text-5xl lg:text-6xl font-bold font-slant text-gray-800"},e))},h2:function(e){return l.a.createElement("h2",Object.assign({className:"text-xl lg:text-3xl font-bold font-slant my-4"},e))},h3:function(e){return l.a.createElement("h3",Object.assign({className:"text-xl lg:text-3xl font-bold font-slant mt-6 mb-2 text-gray-600"},e))},h4:function(e){return l.a.createElement("h4",Object.assign({className:"text-xl lg:text-2xl font-bold mt-6 mb-1"},e))},p:function(e){return l.a.createElement("p",Object.assign({className:"text-xl lg:text-2xl leading-normal mb-4"},e))},ul:function(e){return l.a.createElement("ul",Object.assign({className:"pl-12 my-4 list-disc"},e))},ol:function(e){return l.a.createElement("ul",Object.assign({className:"pl-12 my-4 list-decimal"},e))},li:function(e){return l.a.createElement("li",Object.assign({className:"text-xl lg:text-2xl leading-normal mb-4"},e))}};var b={_frontmatter:{}},c=function(e){var t=e.children;return l.a.createElement(o.a,{components:s},t)};function h(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,["components"]);return Object(o.b)(c,Object.assign({},b,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h1",null,"Digging into Laravel relationships"),Object(o.b)("div",{className:"bg-blue-100 p-4 border border-blue-200 rounded my-4 flex items-center"},Object(o.b)("div",{className:"w-10"},Object(o.b)("svg",{className:"w-6 h-6 text-blue-800 fill-current",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 512 512"},Object(o.b)("path",{d:"M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 448c-110.532 0-200-89.431-200-200 0-110.495 89.472-200 200-200 110.491 0 200 89.471 200 200 0 110.53-89.431 200-200 200zm0-338c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"}))),Object(o.b)("div",{className:"flex-1"},"I've been spending some time digging into the anatomy of Laravel relationships. I'm using this a place to keep notes that I may some day work into a more useful article.")),Object(o.b)("h3",null,"Model > HasRelationships"),Object(o.b)("p",null,"This trait is more related to the relationship attributes and instances—setting,\ngetting, checking the existence of, etc. The other functionality revolves around\ninstantiating ",Object(o.b)("inlineCode",{parentName:"p"},"Relation")," objects and guessing key names/etc when not provided."),Object(o.b)("h4",null,"$relations"),Object(o.b)("p",null,"This is an array that holds all the loaded relationships for the model."),Object(o.b)("h4",null,"$touches"),Object(o.b)("p",null,'This is a list of all relationships that should be "touched" when the model is saved.'),Object(o.b)("h4",null,"static function resolveRelationUsing($name, Closure $callback)"),Object(o.b)("p",null,"This lets you define relationships outside of the model itself, which are then resolved when\n",Object(o.b)("inlineCode",{parentName:"p"},"Model::__call()")," is used to load the relationship. Not really recommended unless you're dynamically\ncreating relationships for models inside a package."),Object(o.b)("h4",null,"hasX, morphX, belongsToX, etc"),Object(o.b)("p",null,"These methods are just helpers to instantiate a Relation object."),Object(o.b)("h4",null,"touchOwners()"),Object(o.b)("p",null,"This loops through all the ",Object(o.b)("inlineCode",{parentName:"p"},"$touches")," models and calls ",Object(o.b)("inlineCode",{parentName:"p"},"$this->$relation()->touch()"),". It\nalso runs recursively, so that each relation that's touched also calls ",Object(o.b)("inlineCode",{parentName:"p"},"touchOwners()"),"\non all its configured ",Object(o.b)("inlineCode",{parentName:"p"},"$touches"),"."),Object(o.b)("h3",null,"Eloquent Builder"),Object(o.b)("h4",null,"$eagerLoad"),Object(o.b)("p",null,"This is the array of relationships that need to be eager loaded. They're set using ",Object(o.b)("inlineCode",{parentName:"p"},"with()"),"."),Object(o.b)("h4",null,"eagerLoadRelations()"),Object(o.b)("p",null,"Calls protected method ",Object(o.b)("inlineCode",{parentName:"p"},"eagerLoadRelations")," for each ",Object(o.b)("inlineCode",{parentName:"p"},"$eagerLoad")),Object(o.b)("h4",null,"eagerLoadRelation()"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Get the relation via ",Object(o.b)("inlineCode",{parentName:"p"},"getRelation()")," (which loads it without constraints and\napplies any nest ",Object(o.b)("inlineCode",{parentName:"p"},"with()")," statements as needed)")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Calls ",Object(o.b)("inlineCode",{parentName:"p"},"addEagerConstraints()")," on the relation")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Applies any custom constraints to the relationship query that were passed in as\narguments to the ",Object(o.b)("inlineCode",{parentName:"p"},"with()")," call (just calls the closure)")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Matches the results back to the parent models by calling ",Object(o.b)("inlineCode",{parentName:"p"},"match()")," on the relation"))),Object(o.b)("h3",null,"Eloquent Builder > QueriesRelationship"),Object(o.b)("h4",null,"has()"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"has()")," method is used under the hood for ",Object(o.b)("inlineCode",{parentName:"p"},"whereHas"),"/",Object(o.b)("inlineCode",{parentName:"p"},"orHas"),"/",Object(o.b)("inlineCode",{parentName:"p"},"doesntHave"),"/etc. It's\nresponsible for checking for the existence or count of a relation inside a model query."),Object(o.b)("p",null,"The basic anatomy of a ",Object(o.b)("inlineCode",{parentName:"p"},"has()")," call:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Get an instance of the relation by calling ",Object(o.b)("inlineCode",{parentName:"p"},"getRelationWithoutConstraints()"),"—this specifically\nloads the relationship without any default constraints applied.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Call ",Object(o.b)("inlineCode",{parentName:"p"},"getRelationExistenceQuery()")," or ",Object(o.b)("inlineCode",{parentName:"p"},"getRelationExistenceCountQuery()")," depending on\nwhether the ",Object(o.b)("inlineCode",{parentName:"p"},"$count")," matters (if we're doing ",Object(o.b)("inlineCode",{parentName:"p"},">= 1")," then ",Object(o.b)("inlineCode",{parentName:"p"},"where exists")," is the same\nsemantics but a faster query, and if we're doing ",Object(o.b)("inlineCode",{parentName:"p"},"< 1")," then the same is true for\n",Object(o.b)("inlineCode",{parentName:"p"},"where not exists"),").")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"If a callback was added, apply the callback using ",Object(o.b)("inlineCode",{parentName:"p"},"Builder::callScope")," which is\nresponsible for merging in ",Object(o.b)("inlineCode",{parentName:"p"},"where")," statements/etc. The most important thing to note\nhere is that if our callback adds additional ",Object(o.b)("inlineCode",{parentName:"p"},"where")," statements to the query, the\n",Object(o.b)("inlineCode",{parentName:"p"},"callScope")," method will wrap them in a group so that ",Object(o.b)("inlineCode",{parentName:"p"},"or where")," statements don't impact\nthe rest of the query.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Call ",Object(o.b)("inlineCode",{parentName:"p"},"addHasWhere")," to add our newly instantiated subquery to the builder:")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"This first calls ",Object(o.b)("inlineCode",{parentName:"p"},"Builder::mergeConstraintsFrom")," to ensure that any custom\nconstraints that are defined in the model's ",Object(o.b)("inlineCode",{parentName:"p"},"newBaseQueryBuilder")," or\n",Object(o.b)("inlineCode",{parentName:"p"},"newEloquentBuilder")," methods are properly applied.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Then it either calls ",Object(o.b)("inlineCode",{parentName:"p"},"addWhereExistsQuery")," or ",Object(o.b)("inlineCode",{parentName:"p"},"addWhereCountQuery")," using the same\nheuristics from above, adding the either a ",Object(o.b)("inlineCode",{parentName:"p"},"Where")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Exists")," statement to the\nunderlying query builder."))),Object(o.b)("h4",null,"withAggregate()"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"withAggregate()")," method is responsible for all the ",Object(o.b)("inlineCode",{parentName:"p"},"withCount"),"/",Object(o.b)("inlineCode",{parentName:"p"},"withMax"),"/etc calls:"),Object(o.b)("h2",null,"Relation Interface"),Object(o.b)("p",null,"These are the relationship methods that seem to actually matter to outside callers:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Relation::noConstraints")," — tells relationships to load without the default constraints. This\nsets a static property that relationships have to check during ",Object(o.b)("inlineCode",{parentName:"li"},"__construct()")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"getRelationExistenceQuery")," — gets the version of the relationship for checking the existence\nof the related models. This is usually a ",Object(o.b)("inlineCode",{parentName:"li"},"where exists ( ... )")," subquery."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"getRelationExistenceCountQuery")," — same as above but for when the count matters"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"getRelated")," — get the model for use in the relationship"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"getRelationCountHash")," — get an alias name that can be used when joining a table to itself\nor for other cases where a distinction needs to be made between multiple references to the\nsame table. Generally results in ",Object(o.b)("inlineCode",{parentName:"li"},'"laravel_reserved_X"')," where ",Object(o.b)("inlineCode",{parentName:"li"},"X")," is incremented each time."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"getResults")," — get the results of the query in a non-eager call"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"getEager")," — get the results of the query in an eager call"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"addEagerConstraints")," — tells the relation to apply eager constraints to the query"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"match")," — responsible for matching results back to parent models"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"initRelation")," — initialize the relation before query. In the case of a hasMany, for instance,\nthis will set up an empty Eloquent Collection"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"touch")," — updates the ",Object(o.b)("inlineCode",{parentName:"li"},"updated_at")," timestamp for the related model"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"getQuery")," — returns the underlying ",Object(o.b)("strong",{parentName:"li"},"Eloquent")," query builder (",Object(o.b)("inlineCode",{parentName:"li"},"getBaseQuery")," gets the underlying\nbase query builder, but it doesn't seem like that's used anywhere in the framework)")),Object(o.b)("h2",null,"General Notes"),Object(o.b)("p",null,"In ",Object(o.b)("inlineCode",{parentName:"p"},"HasRelationships::morphTo")," the framework uses the lack of attributes to determine if a relation\nshould be instantiated in an eager/non-eager context."),Object(o.b)("p",null,"It's necessary to handle self-relationships where a table may be joined in multiple\ntimes, and therefore needs to do something like ",Object(o.b)("inlineCode",{parentName:"p"},"getRelationExistenceQueryForSelfRelation")," "),Object(o.b)("h2",null,"Half-baked thoughts :)"),Object(o.b)("p",null,"If we're trying to build a more generic implementation of relationships, the things that\nmatter in particular are:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"getRelationExistenceCountQuery")," (",Object(o.b)("inlineCode",{parentName:"li"},"getRelationExistenceQuery")," is technically just an optimization)"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"match")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"addEagerConstraints"))),Object(o.b)("p",null,"We neeed to be able to create the following queries:"),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-mysql"}),"select count(*)\nfrom related_table\nwhere related_table.local_key = parent_table.foreign_key\n")),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-mysql"}),"select *\nfrom related_table\nwhere related_table.local_key = ?\n")),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-mysql"}),"select *\nfrom related_table\nwhere related_table.local_key in (?, ?, ?)\n")),Object(o.b)("p",null,"This means that we need an API something like:"),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-php"}),"// For simple cases where you really only need to match related instances\n// back using a single attribute\nRelatedModel::query()\n    ->where('special_attribute', '>', 42)\n    ->asRelation()\n    ->match($model); // same as ->matchOn($model, $model->getKeyName(), (new RelatedModel()->getForeignKey())\n\n// For complex cases where you need to handle custom logic when matching\n// results back to the eager-loaded collection\nRelatedModel::query()\n    ->where('special_attribute', '>', 42)\n    ->asRelation()\n    ->match(function(array $models, Collection $results, string $relation) {});\n")),Object(o.b)("p",null,"In non-eager contexts, ",Object(o.b)("inlineCode",{parentName:"p"},"match($model)")," would just add a simple constraint to the\nquery builder (i.e. ",Object(o.b)("inlineCode",{parentName:"p"},"where user_id = 1"),"). We'd need a way to indicate the direction\nof the matching (i.e. belongs to or has), which maybe would need to be a separate\nfunction."),Object(o.b)("p",null,"In eager contexts, this could easily generate the ",Object(o.b)("inlineCode",{parentName:"p"},"where in()")," in the same manner\nand then do the matching the same way traditional relationships work."))}h.isMDXComponent=!0,n.d(t,"default",(function(){return p}));function p(){return l.a.createElement(i.a,null,l.a.createElement(r.a,{title:"Digging into Laravel relationships - Chris Morrell"}),l.a.createElement(h,null))}}}]);
//# sourceMappingURL=component---src-pages-laravel-relationships-js-c02c80d7711d5eb417bd.js.map